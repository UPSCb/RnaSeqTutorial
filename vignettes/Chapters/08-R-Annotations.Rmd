```{r inv-0401, echo=FALSE}
    startQuest("Annotation packages")
```

```{r head-0401, echo=FALSE}
    h1("Annotation of Genes and Genomes")
```

In the previous chapter, we have seen how aligned reads can be manipulated
and what are the crucial caveats to be aware of; _i.e._ stranded _vs._ 
non-stranded data and multi-mapping reads discard. In the present chapter, we
will look at how genic annotation are retrieved and processed. Here again we 
will introduce how this is commonly done and what caveats this implies.

```{r message=FALSE,warning=FALSE,results='hide',echo=FALSE}
    options(digits=2)
    library(RnaSeqTutorial)
```

Bioconductor provides extensive annotation resources, summarized in
the following figure. These can be *gene*-, or *genome*-centric.
Annotations can be provided in packages curated by `Bioconductor`, 
or obtained from web-based resources.  
Gene-centric `AnnotationDbi` packages include:

-   Organism level: e.g. `org.Mm.eg.db`,
    `Homo.sapiens`.

-   Platform level: e.g. `hgu133plus2.db`,
    `hgu133plus2.probes`,
    `hgu133plus2.cdf`.

-   Homology level: e.g. `hom.Dm.inp.db`.

-   System biology level: `GO.db`,
    `KEGG.db`, `Reactome.db`.

Examples of genome-centric packages include:

-   `GenomicFeatures`, to represent genomic features,
    including constructing reproducible feature or transcript databases
    from local file or web resources.

-   Pre-built transcriptome packages, e.g.
    `TxDb.Hsapiens.UCSC.hg19.knownGene` based on the
    UCSC hg19 knownGenes track.

-   `BSgenome` for whole genome sequence representation
    and manipulation.

-   Pre-built genomes, e.g.,
    `BSgenome.Hsapiens.UCSC.hg19` based on the UCSC hg19
    build.

Web-based resources include

-   `biomaRt` to query
    [biomart](http://www.biomart.org/) resource for genes, sequence,
    SNPs, and etc.

-   `rtracklayer` for interfacing with browser tracks,
    especially the [UCSC](http:://genome.ucsc.edu) genome browser.

-   genome projects often provide `gff3` (General
    Feature Format) or `gtf` (Gene Transfer Format)
    formatted files as annotation sources, which can be manipulated with
    the `rtracklayer` or `genomeIntervals` packages.

![Annotation Packages: the big picture][dbtypes]

Here, we will focus on the Genome-centric type of approaches using
the GenomicFeatures package.

```{r head-0404, echo=FALSE}
h2("Genome-centric annotations with `GenomicFeatures`")
```

Genome-centric packages are very useful for annotations involving
genomic coordinates. It is straight-forward, for instance, to discover
the coordinates of coding sequences in regions of interest, and from
these retrieve corresponding DNA or protein coding sequences. Other
examples of the types of operations that are easy to perform with
genome-centric annotations include defining regions of interest for
counting aligned reads in RNA-seq experiments and retrieving DNA
sequences underlying regions of interest in ChIP-seq analysis, e.g., for
motif characterization.

-   Load the ‘transcript.db’ package relevant to the dm3 build of
    *D. melanogaster*.

-   Use `select` and friends to select the Flybase gene
    ids of the top table and the Flybase transcript names (TXNAME) and
    Entrez gene identifiers (GENEID).

-   Use `cdsBy` to extract all coding sequences, grouped
    by transcript.

-   Subset the coding sequences to contain just the transcripts relevant
    to the top table.

-   How many transcripts are there?

-   What is the structure of the first transcript’s coding sequence?

-   Load the ‘BSgenome’ package for the dm3 build of *D. melanogaster*.

-   Use the coding sequences ranges of the previous part of this
    exercise to extract the underlying DNA sequence, using the
    `extractTranscriptSeqs` function.

-   Use `Biostrings`’s `translate`
    function to convert DNA to amino acid sequences.

The following loads the relevant Transcript.db package, and creates a
more convenient alias to the `TranscriptDb` instance
defined in the package.

```{r}
    library(TxDb.Dmelanogaster.UCSC.dm3.ensGene)
    txdb <- TxDb.Dmelanogaster.UCSC.dm3.ensGene
```

We can discover available keys (using `keys`) and
columns (`columns`) in `txdb`, and then
use `select` to retrieve the transcripts associated with
each differentially expressed gene. The mapping between gene and
transcript is not one-to-one – some genes have more than one
transcripts, which is biologically relevant, and some may have none,
which might be due to different database versions being used or database
cross-references (xref) inconsistancies.

```{r}
    set.seed(123)
    fbids <- sample(keys(txdb),10,FALSE,)
    txnm <- select(txdb, fbids, "TXNAME", "GENEID")
    nrow(txnm)
    head(txnm, 3)
```

The `TranscriptDb` instances can be queried for data
that is more structured than simple data frames, and in particular
return `GRanges` or `GRangesList`
instances to represent genomic coordinates. These queries are performed
using `cdsBy` (coding sequence),
`transcriptsBy` (transcripts), , where the function
argument `by` specifies how coding sequences or
transcripts are grouped. Here we extract the coding sequences grouped by
transcript, returning the transcript names, and subset the resulting
`GRangesList` to contain just the transcripts of
interest to us. The sixth transcript is composed of 8 distinct coding
sequence regions.

```{r}
    cds <- cdsBy(txdb, "tx", use.names=TRUE)[txnm$TXNAME[6]]
    cds[1]
```

The following code loads the appropriate BSgenome package; the object
refers to the whole genome sequence represented in this package. The
remaining steps extract the DNA sequence of each transcript, and
translates these to amino acid sequences. Issues of strand are handled
correctly.

```{r}
    library(BSgenome.Dmelanogaster.UCSC.dm3)
    txx <- extractTranscriptSeqs(Dmelanogaster, cds)
    length(txx)
    head(txx, 3)
    head(translate(txx), 3)
```

```{r inv-0402, echo=FALSE}
quest(6)
endQuest()
startQuest("Reading a GFF3")
```

```{r head-0405, echo=FALSE}
h2("Creating a synthetic set of transcripts")
```

One major caveat estimating gene expression using aligned RNA-Seq reads
is that a single read, which originated from a single mRNA molecule, can
be aligned to several features ( transcripts or genes) if those
alignments are of equivalent quality. This happens as a result of gene
duplication and the presence of repetitive or common domains, for
example. To avoid this, it is best practice to adopt a conservative
approach by collapsing all existing transcripts of a single gene locus
into a “synthetic” transcript containing every exon of that gene. In the
case of overlapping exons, the longest genomic interval is kept, _i.e._ an
artificial exon is created. This process results in a flattened
transcript-gene structure with a one to one relationship. As this
procedure varies from organism to organism, there is, to the best of our
knowledge, no tool available for performing this step.

Here, we will inspire ourselves (ha-ha) from the documentation
of the R/Bioconductor easyRNASeq package [@easyRNASeq]; 
paragraph 7.1 of the package vignette.

First, we load the necessary libraries

```{r}
library(IRanges)
library(genomeIntervals)
```

Next, we read in the GFF3 file

```{r}
gff <- readGff3(file.path(extdata(),
                          "GFF3/Ptrichocarpa_v3.0_210_gene_exons.gff3.gz"),
                quiet=TRUE)
```

```{r inv-0403, echo=FALSE}
quest(7)
endQuest()
startQuest("Examining the GFF3")
```

And have a look at the Genome_Intervals object content

```{r}
gff
nrow(gff[gff$type=="exon",])
nrow(gff[gff$type=="mRNA",])
nrow(gff[gff$type=="gene",])
```

```{r inv-0404, echo=FALSE}
quest(8)
endQuest()
startQuest("Extracting the mRNA and exons")
```

Here, we do not ask you to understand every detail of the implementation, but
rather to get an idea of the process.

First, we identify the ID and Parents of all mRNA features and create a mapping
table from it.

```{r}
sel <- gff$type == "mRNA"
transcriptGeneMapping <- data.frame(getGffAttribute(gff[sel], "ID"), 
                                    getGffAttribute(gff[sel], "Parent")
)
head(transcriptGeneMapping)
```

Next, we select the exon features and sort them in "groups" by their `Parent`.

```{r}
sel <- gff$type=="exon"
rngList<- split(IRanges(start=gff[sel,1],end=gff[sel,2]),
                transcriptGeneMapping[match(
                  sapply(strsplit(getGffAttribute(gff[sel,],"Parent"),","),"[",1),
                  transcriptGeneMapping$ID),"Parent"])
rngList
mostExons <- rev(names(table(elementNROWS(rngList))))[1]
mostExons
```

```{r inv-0405, echo=FALSE}
quest(9)
endQuest()
startQuest("Flattening the exon")
```

Then, we reduce the exon structure

```{r}
rngList<- IRanges::reduce(rngList)
rngList
rev(names(table(elementNROWS(rngList))))[1]
```

```{r inv-0406, echo=FALSE}
quest(10)
endQuest()
startQuest("Creating the gff")
```

Once we have reduced the transcript complexity, we can reconstruct a GFF
structure from it.

First, we get the gff information; here we simply duplicate the
first exon of every gene by the number of synthetic 
exons per gene. The content will be updated afterwards.

```{r}
exons <- gff[sel,]
syntheticGeneModel<- exons[rep(
  match(names(rngList),
        transcriptGeneMapping[
          match(sapply(strsplit(getGffAttribute(exons,"Parent"),","),"[",1),
                transcriptGeneMapping$ID),"Parent"]),
  elementNROWS(rngList)),]
```

Then, we update the coordinates, and change the source. This latter step is to 
document our changes; _i.e._ to make it obvious to anyone using that the newly 
generated annotation are not the original ones.

```{r}
syntheticGeneModel[,1]<- unlist(start(rngList))
syntheticGeneModel[,2]<- unlist(end(rngList))
levels(syntheticGeneModel$source)<- "inhouse"
```

Next, we get the exon number for both strands. As the exons are correctly 
ordered on the minus strands by our first command - _i.e._ in decreasing order, 
we have to revert those on the plus strand.

```{r}
exonNumber<- lapply(elementNROWS(rngList),":",1)
sel<- strand(syntheticGeneModel)[cumsum(elementNROWS(rngList))] == "+"
exonNumber[sel]<- sapply(exonNumber[sel],rev)
```

This is followed by the attributes (the ninth column) update.

```{r}
syntheticGeneModel$gffAttributes<- paste("ID=",
                                         rep(names(rngList),elementNROWS(rngList)),
                                         ":",unlist(exonNumber),";Parent=",
                                         rep(names(rngList),elementNROWS(rngList)),".0",sep="")
```

Before, eventually writing the newly generated annotation in different formats.

```{r}
writeGff3(syntheticGeneModel,file="~/Ptrichocarpa_v3.0_210_synthetic_transcripts.gff3")

sel <- syntheticGeneModel$type=="exon"
annot <- split(GRanges(seqnames=seq_name(syntheticGeneModel[sel]),
                       ranges=IRanges(start=syntheticGeneModel[sel,1],
                                      end=syntheticGeneModel[sel,2]),
                       strand=strand(syntheticGeneModel[sel])),
               getGffAttribute(syntheticGeneModel,"Parent")[sel,1]
)

save(annot,file="~/Ptrichocarpa_v3.0_210_synthetic_transcripts.rda")
```

```{r inv-0407, echo=FALSE}
quest(11)
endQuest()
startQuest("Alternative")
```

```{r head-0406, echo=FALSE}
h3("Alternative")
```
__Note: The same can actually be done with a single call to the "easyRNASeq" "createSyntheticTranscripts" function__
```{r}
synthTrx <- createSyntheticTranscripts(
    file.path(extdata(),"GFF3/Ptrichocarpa_v3.0_210_gene_exons.gff3.gz"),
    verbose=FALSE)
```

```{r inv-0408, echo=FALSE}
endQuest()
```
